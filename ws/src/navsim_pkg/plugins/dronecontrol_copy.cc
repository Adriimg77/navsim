#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>


#include <Eigen/Core>
#include <Eigen/Geometry>

#include <stdio.h>
#include <iostream>
#include <cmath>

//Custom messages from utrafman simulator

namespace gazebo
{
    class DroneControl : public ModelPlugin
    {
    private:

        // Pointers to the model and the link
        physics::ModelPtr model;
        physics::LinkPtr link;

        // Pointer to the update event connection
        event::ConnectionPtr updateConnection;

        //Needed to control telemetry publish
        common::Time last_odom_publish_time;
        double odom_publish_rate = 1; // updates per second


        //Topic structures
        std::string uplans_topic = "uplan";
        std::string telemetry_topic = "telemetry";
        std::string kill_topic = "kill";

        //Drone and U-plan execution
        std::string id;
        bool uplan_inprogress = false;

        //To control navigation
        int actual_route_point;

        //Log file
        std::ofstream control_out_file;


        //-------------------------------------------------------------------------------------------------

        // Drone parameters
        //Rotors position at distance 15cms from the center of mass, inclination 45º from the axes
    private:
        const double g = 9.8;
        const double mass = 0.595;
        ignition::math::Vector3<double> pos_CM = ignition::math::Vector3<double>(0, 0, 0);              // center of mass
        ignition::math::Vector3<double> pos_NE = ignition::math::Vector3<double>( 0.075, -0.075, 0);   // cosd(45º) * 0.15m
        ignition::math::Vector3<double> pos_NW = ignition::math::Vector3<double>( 0.075,  0.075, 0);
        ignition::math::Vector3<double> pos_SE = ignition::math::Vector3<double>(-0.075, -0.075, 0);
        ignition::math::Vector3<double> pos_SW = ignition::math::Vector3<double>(-0.075,  0.075, 0);

        // Max and minimum angular velocity of the motors
        const double w_max = 628.3185;      // rad/s = 6000rpm
        const double w_min = 0;             // rad/s =    0rpm

        // Aero-dynamic thrust force constant
        // Force generated by the rotors is FT = kFT * w² 
        const double kFT = 1.7179e-05;                 // assuming that FT_max = 0.692kg
        const double w_hov = sqrt(mass * g / 4 /kFT);  // 628.3185 rad/s

        //Aero-dynamic drag force constant
        //Moment generated by the rotors is MDR = kMDR * w²
        const double kMDR = 3.6714e-08;

        //Aero-dynamic drag force constant per axis
        //Drag force generated by the air friction, opposite to the velocity is FD = -kFD * r_dot*|r_dot| (depends on the shape of the object in each axis).
        // Horizontal axis:
        const double kFDx = 1.1902e-04;
        const double kFDy = 1.1902e-04;
        // Vertical axis:
        const double kFDz = 0.003644;


        //Aero-dynamic drag moment constant per axis
        //Drag moment generated by the air friction, opposite to the angular velocity is MD = -kMD * rpy_dot*|rpy_dot| (depends on the shape of the object in each axis).

        // Horizontal axis:
        //Assuming similar drag in both axes (although the fuselage is not equal), no gravity and the drone is propulsed by two rotors of the same side at maximum speed the maximum angular velocity is Vrp_max = 2 * 2*pi;
        //operating kMDxy =  2 * FT_max * sin(deg2rad(45))^2 / Vrp_max^2 we get that...
        const double kMDx = 1.1078e-04;
        const double kMDy = 1.1078e-04;

        //Vertical axis:
        //Must be verified at maximum yaw velocity
        //Assuming tjat Vyaw_max = 4*pi rad/s (max yaw velocity of 2rev/s) and w_hov2 (rotor speed to maintain the hovering)
        //And taking into account that MDR = kMDR * w² and MDz = kMDz * Vyaw²
        //operating MDz  = MDR (the air friction compensates the effect of the rotors) and kMDz = kMDR* (2 * w_hov2²) / Vyaw_max² we get that...
        const double kMDz = 7.8914e-05;  

//------------------------------------------------------------------------------------------------------

        // Control commands variables
        double cmd_on   = 1;

        double cmd_velX =  2.0;
        double cmd_velY =  0.0;
        double cmd_velZ =  0.0;
        double cmd_rotZ =  1.0; 

        // Control matrices variables
        Eigen::Matrix<double, 8, 1> x;  // model state
        Eigen::Matrix<double, 4, 1> y;  // model output
        Eigen::Matrix<double, 4, 8> K;  // state control matrix
        Eigen::Matrix<double, 4, 8> Kx; // state control matrix
        Eigen::Matrix<double, 4, 4> Ky; // error control matrix
        Eigen::Matrix<double, 4, 1> Hs; // hovering speed
        Eigen::Matrix<double, 4, 1> Wr; // rotors speeds
        Eigen::Matrix<double, 4, 1> r;  // model reference
        Eigen::Matrix<double, 4, 1> e;  // model error
        Eigen::Matrix<double, 4, 1> E;  // model acumulated error
        Eigen::Matrix<double, 4, 1> u;  // input

        int E_max = 6;                      //Max error
        common::Time prev_iteration_time;   // Time to integrate the acumulated error


    public:
        //Executed when the plugin is loaded in Gazebo
        void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf)
        {
            printf("DRONE CHALLENGE Drone plugin: LOAD\n");

            // Store pointers to the model
            this->model = _parent;
            this->link = model->GetLink("dronelink");

            // Listen to the update event. This event is broadcast every iteration.
            this->updateConnection = event::Events::ConnectWorldUpdateBegin(
                    boost::bind(&DroneControl::OnUpdate, this, _1));


            // Getting Drone ID
            if(!_sdf->HasElement("id")){
                std::cout << "Missing parameter <id> in PluginCall, default to 0" << std::endl;
                this->id = "0";
            } else {
                this->id = _sdf->GetElement("id")->GetValue()->GetAsString();
            }

            //Init last_odom_publish_time
            last_odom_publish_time = model->GetWorld()->SimTime();


            //Initial control matrices
            Kx <<  -47.4820, -47.4820, -9.3626, -9.3626,  413.1508, -10.5091,  10.5091,  132.4440,
                    47.4820, -47.4820,  9.3626, -9.3626, -413.1508, -10.5091, -10.5091,  132.4440,
                   -47.4820,  47.4820, -9.3626,  9.3626, -413.1508,  10.5091,  10.5091,  132.4440,
                    47.4820,  47.4820,  9.3626,  9.3626,  413.1508 , 10.5091, -10.5091 , 132.4440;

            Ky <<   -8.1889,  8.1889,  294.3201,  918.1130,
                    -8.1889, -8.1889,  294.3201, -918.1130,
                     8.1889,  8.1889,  294.3201, -918.1130,
                     8.1889, -8.1889,  294.3201,  918.1130;

            // Linearization point
            Hs << w_hov, w_hov, w_hov, w_hov;
            // Rotor real speeds
            Wr << 0, 0, 0, 0;
            //Reference to follow
            r << 0, 0, 0, 0;
            //Cumulative error in the reference following
            E << 0, 0, 0, 0;
            //Control input signal
            u << 0, 0, 0, 0;
        }

        // Called by the world update start event
        void OnUpdate(const common::UpdateInfo &evento /*_info*/)
        {
            std::cout << "\x1B[2J\x1B[H";  // borra pantalla
            printf("DRONE CHALLENGE Drone plugin: OnWorldUpdateBegin\n\n");

            // Check if the simulation was reset
            common::Time current_time = model->GetWorld()->SimTime();
            if (current_time < prev_iteration_time)
                // The simulation was reset
                prev_iteration_time = current_time;

            //Time since the last iteration
            double seconds_since_last_iteration = (current_time - prev_iteration_time).Double();
            prev_iteration_time = current_time;

            //Getting position, rotations and velocities of the drone
            ignition::math::Pose3<double> pose = model->WorldPose();
            ignition::math::Vector3<double> pose_rot = pose.Rot().Euler();
            ignition::math::Vector3<double> linear_vel = model->RelativeLinearVel();
            ignition::math::Vector3<double> angular_vel = model->RelativeAngularVel();
            printf("drone         vel xyz =  %.2f  %.2f  %.2f\n",  linear_vel.X(),  linear_vel.Y(),  linear_vel.Z());
            printf("drone angular vel xyz =  %.2f  %.2f  %.2f\n", angular_vel.X(), angular_vel.Y(), angular_vel.Z());



            //Low level control
            if (cmd_on){
                //Assign the model state
                x(0, 0) = pose_rot.X();     // ePhi
                x(1, 0) = pose_rot.Y();     // eTheta
                x(2, 0) = angular_vel.X();  // bWx
                x(3, 0) = angular_vel.Y();  // bWy
                x(4, 0) = angular_vel.Z();  // bWz
                x(5, 0) = linear_vel.X();   // bXdot
                x(6, 0) = linear_vel.Y();   // bYdot
                x(7, 0) = linear_vel.Z();   // bZdot

                //Assign the model output
                y(0, 0) = linear_vel.X();   // bXdot
                y(1, 0) = linear_vel.Y();   // bYdot
                y(2, 0) = linear_vel.Z();   // bZdot
                y(3, 0) = angular_vel.Z();  // bWz

                //Velocities commanded in world axes
                Eigen::Matrix<double, 3, 1> h_cmd;
                h_cmd(0, 0) = cmd_velX;     // eXdot
                h_cmd(1, 0) = cmd_velY;     // eYdot
                h_cmd(2, 0) = cmd_velZ;     // eZdot

                //Matrix of transformation from world axes to drone body axes
                Eigen::Matrix<double, 3, 3> horizon2body;
                horizon2body = Eigen::AngleAxisd(-x(0, 0), Eigen::Vector3d::UnitX())    // roll
                               * Eigen::AngleAxisd(-x(1, 0), Eigen::Vector3d::UnitY()); // pitch

                // Transfrom the horizon command to body command
                Eigen::Matrix<double, 3, 1> b_cmd;
                b_cmd = horizon2body * h_cmd;

                // Assign the model reference to be followed
                r(0, 0) = b_cmd(0, 0);      // bXdot
                r(1, 0) = b_cmd(1, 0);      // bYdot
                r(2, 0) = b_cmd(2, 0);      // bZdot
                r(3, 0) = cmd_rotZ;                  // hZdot
                // std::cout  << "r:  " << r.transpose()  << " \n\n";

                // Error between the output and the reference (between the commanded velocity and the drone velocity)
                e = y - r;
                e = e * seconds_since_last_iteration;

                // Cumulative error
                E = E + e;

                // Trunc the cumulative error
                if (E(0, 0) >  E_max){
                    E(0, 0) =  E_max;
                }

                if (E(0, 0) < -E_max){
                    E(0, 0) = -E_max;
                }

                if (E(1, 0) >  E_max){
                    E(1, 0) =  E_max;
                }

                if (E(1, 0) < -E_max){
                    E(1, 0) = -E_max;
                }

                if (E(2, 0) >  E_max){
                    E(2, 0) =  E_max;
                }

                if (E(2, 0) < -E_max){
                    E(2, 0) = -E_max;
                }

                if (E(3, 0) >  E_max){
                    E(3, 0) =  E_max;
                }

                if (E(3, 0) < -E_max){
                    E(3, 0) = -E_max;
                }

                //Rotors speed
                u = Hs - Kx * x - Ky * E;
                // std::cout  << "u: " << u.transpose()  << " \n\n";


            } else {
                //Reset the cumulative error and the rotors speed
                E << 0, 0, 0, 0;
                u << 0, 0, 0, 0;
            }

            // Assign the rotors speed with the input
            Wr = u;

            //Saturating the rotors speed in case of exceeding the maximum or minimum rotations
            if (Wr(0, 0) > w_max) Wr(0, 0) = w_max;
            if (Wr(0, 0) < w_min) Wr(0, 0) = w_min;
            if (Wr(1, 0) > w_max) Wr(1, 0) = w_max;
            if (Wr(1, 0) < w_min) Wr(1, 0) = w_min;
            if (Wr(2, 0) > w_max) Wr(2, 0) = w_max;
            if (Wr(2, 0) < w_min) Wr(2, 0) = w_min;
            if (Wr(3, 0) > w_max) Wr(3, 0) = w_max;
            if (Wr(3, 0) < w_min) Wr(3, 0) = w_min;

            //Assign the rotors speed
            double w_rotor_NE = Wr(0, 0);
            double w_rotor_NW = Wr(1, 0);
            double w_rotor_SE = Wr(2, 0);
            double w_rotor_SW = Wr(3, 0);

            // // con esto simulamos rotacion de sustentacion
            // w_rotor_NE = w_hov;
            // w_rotor_NW = w_rotor_NE;
            // w_rotor_SE = w_rotor_NE;
            // w_rotor_SW = w_rotor_NE;

            // // con esto simulamos rotacion de giro
            // w_rotor_NE = 411.9621;
            // w_rotor_NW = 0;
            // w_rotor_SE = 0;
            // w_rotor_SW = 411.9621;
            

            //Apply the thrust force to the drone
//            printf("Fuerza del motor %.4f\n",mass*g/4);

            ignition::math::Vector3<double> FT_NE = ignition::math::Vector3<double>(0, 0, kFT * pow(w_rotor_NE, 2));
            ignition::math::Vector3<double> FT_NW = ignition::math::Vector3<double>(0, 0, kFT * pow(w_rotor_NW, 2));
            ignition::math::Vector3<double> FT_SE = ignition::math::Vector3<double>(0, 0, kFT * pow(w_rotor_SE, 2));
            ignition::math::Vector3<double> FT_SW = ignition::math::Vector3<double>(0, 0, kFT * pow(w_rotor_SW, 2));
            link->AddLinkForce(FT_NE, pos_NE);
            link->AddLinkForce(FT_NW, pos_NW);
            link->AddLinkForce(FT_SE, pos_SE);
            link->AddLinkForce(FT_SW, pos_SW);


            //Apply the drag moment to the drone
            ignition::math::Vector3<double> MDR_NE = ignition::math::Vector3<double>(0, 0, kMDR * pow(w_rotor_NE, 2));
            ignition::math::Vector3<double> MDR_NW = ignition::math::Vector3<double>(0, 0, kMDR * pow(w_rotor_NW, 2));
            ignition::math::Vector3<double> MDR_SE = ignition::math::Vector3<double>(0, 0, kMDR * pow(w_rotor_SE, 2));
            ignition::math::Vector3<double> MDR_SW = ignition::math::Vector3<double>(0, 0, kMDR * pow(w_rotor_SW, 2));
            link->AddRelativeTorque(MDR_NE - MDR_NW - MDR_SE + MDR_SW);

            // Apply the air friction force to the drone
            ignition::math::Vector3<double> FD = ignition::math::Vector3<double>(
                    -kFDx * linear_vel.X() * fabs(linear_vel.X()),
                    -kFDy * linear_vel.Y() * fabs(linear_vel.Y()),
                    -kFDz * linear_vel.Z() * fabs(linear_vel.Z()));
            link->AddLinkForce(FD, pos_CM);

            // Apply the air friction moment to the drone
            ignition::math::Vector3<double> MD = ignition::math::Vector3<double>(
                    -kMDx * angular_vel.X() * fabs(angular_vel.X()),
                    -kMDy * angular_vel.Y() * fabs(angular_vel.Y()),
                    -kMDz * angular_vel.Z() * fabs(angular_vel.Z()));
            link->AddRelativeTorque(MD);

            // Check if it is time to publish the telemetry
            if (current_time < last_odom_publish_time)
                last_odom_publish_time = current_time; // The simulation was reset



        }

    
        ignition::math::Vector3d EulerTransformation(ignition::math::Vector3d vel, double yaw){
            return ignition::math::Vector3d(vel.X()*cos(yaw) + vel.Y()*sin(yaw), vel.X()*-1*sin(yaw) + vel.Y()* cos(yaw), vel.Z());
        }


    };


// Register this plugin with the simulator
    GZ_REGISTER_MODEL_PLUGIN(DroneControl)
} // namespace gazebo
